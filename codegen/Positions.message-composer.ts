/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { Coin } from "@cosmjs/amino";
import { MsgExecuteContractEncodeObject } from "@cosmjs/cosmwasm-stargate";
import { MsgExecuteContract } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@cosmjs/encoding";
import { Uint128, BadDebtResponse, PositionUserInfo, NativeToken, Addr, Decimal, BasketPositionsResponse, Position, CAsset, Asset, PoolInfo, LPAssetInfo, Basket, SupplyCap, MultiAssetSupplyCap, CollateralInterestResponse, Config, DebtCap, ExecuteMsg, PoolType, CallbackMsg, UpdateConfig, UserInfo, EditBasket, TWAPPoolInfo, InsolvencyResponse, InsolventPosition, InstantiateMsg, InterestResponse, PositionResponse, QueryMsg, RedeemabilityResponse, PremiumInfo, RedemptionInfo, PositionRedemption } from "./Positions.types";
export interface PositionsMsg {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    baseDebtCapMultiplier,
    collateralTwapTimeframe,
    cpcMultiplier,
    creditTwapTimeframe,
    debtAuction,
    debtMinimum,
    dexRouter,
    discountsContract,
    liqFee,
    liquidityContract,
    oracleContract,
    oracleTimeLimit,
    osmosisProxy,
    owner,
    rateSlopeMultiplier,
    stabilityPool,
    stakingContract
  }: {
    baseDebtCapMultiplier?: Uint128;
    collateralTwapTimeframe?: number;
    cpcMultiplier?: Decimal;
    creditTwapTimeframe?: number;
    debtAuction?: string;
    debtMinimum?: Uint128;
    dexRouter?: string;
    discountsContract?: string;
    liqFee?: Decimal;
    liquidityContract?: string;
    oracleContract?: string;
    oracleTimeLimit?: number;
    osmosisProxy?: string;
    owner?: string;
    rateSlopeMultiplier?: Decimal;
    stabilityPool?: string;
    stakingContract?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  deposit: ({
    positionId,
    positionOwner
  }: {
    positionId?: Uint128;
    positionOwner?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  increaseDebt: ({
    ltv,
    amount,
    mintToAddr,
    positionId
  }: {
    ltv?: Decimal;
    amount?: Uint128;
    mintToAddr?: string;
    positionId: Uint128;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  withdraw: ({
    assets,
    positionId,
    sendTo
  }: {
    assets: Asset[];
    positionId: Uint128;
    sendTo?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  repay: ({
    positionId,
    positionOwner,
    sendExcessTo
  }: {
    positionId: Uint128;
    positionOwner?: string;
    sendExcessTo?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  liqRepay: (_funds?: Coin[]) => MsgExecuteContractEncodeObject;
  liquidate: ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  redeemCollateral: ({
    maxCollateralPremium
  }: {
    maxCollateralPremium?: number;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  editRedeemability: ({
    maxLoanRepayment,
    positionIds,
    premium,
    redeemable,
    restrictedCollateralAssets
  }: {
    maxLoanRepayment?: Decimal;
    positionIds: Uint128[];
    premium?: number;
    redeemable?: boolean;
    restrictedCollateralAssets?: string[];
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  closePosition: ({
    maxSpread,
    positionId,
    sendTo
  }: {
    maxSpread: Decimal;
    positionId: Uint128;
    sendTo?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  accrue: ({
    positionIds,
    positionOwner
  }: {
    positionIds: Uint128[];
    positionOwner?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  mintRevenue: ({
    amount,
    repayFor,
    sendTo
  }: {
    amount?: Uint128;
    repayFor?: UserInfo;
    sendTo?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  createBasket: ({
    baseInterestRate,
    basketId,
    collateralTypes,
    creditAsset,
    creditPoolInfos,
    creditPrice,
    liqQueue
  }: {
    baseInterestRate?: Decimal;
    basketId: Uint128;
    collateralTypes: CAsset[];
    creditAsset: Asset;
    creditPoolInfos: PoolType[];
    creditPrice: Decimal;
    liqQueue?: string;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  editBasket: ({
    addedCAsset,
    baseInterestRate,
    collateralSupplyCaps,
    cpcMarginOfError,
    creditAssetTwapPriceSource,
    creditPoolInfos,
    frozen,
    liqQueue,
    multiAssetSupplyCaps,
    negativeRates,
    revToStakers
  }: {
    addedCAsset?: CAsset;
    baseInterestRate?: Decimal;
    collateralSupplyCaps?: SupplyCap[];
    cpcMarginOfError?: Decimal;
    creditAssetTwapPriceSource?: TWAPPoolInfo;
    creditPoolInfos?: PoolType[];
    frozen?: boolean;
    liqQueue?: string;
    multiAssetSupplyCaps?: MultiAssetSupplyCap[];
    negativeRates?: boolean;
    revToStakers?: boolean;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  editcAsset: ({
    asset,
    maxLTV,
    maxBorrowLTV
  }: {
    asset: NativeToken;
    maxLTV?: Decimal;
    maxBorrowLTV?: Decimal;
  }, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
  callback: (callbackMsg: CallbackMsg, _funds?: Coin[]) => MsgExecuteContractEncodeObject;
}
export class PositionsMsgComposer implements PositionsMsg {
  sender: string;
  contractAddress: string;

  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.deposit = this.deposit.bind(this);
    this.increaseDebt = this.increaseDebt.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.repay = this.repay.bind(this);
    this.liqRepay = this.liqRepay.bind(this);
    this.liquidate = this.liquidate.bind(this);
    this.redeemCollateral = this.redeemCollateral.bind(this);
    this.editRedeemability = this.editRedeemability.bind(this);
    this.closePosition = this.closePosition.bind(this);
    this.accrue = this.accrue.bind(this);
    this.mintRevenue = this.mintRevenue.bind(this);
    this.createBasket = this.createBasket.bind(this);
    this.editBasket = this.editBasket.bind(this);
    this.editcAsset = this.editcAsset.bind(this);
    this.callback = this.callback.bind(this);
  }

  updateConfig = ({
    baseDebtCapMultiplier,
    collateralTwapTimeframe,
    cpcMultiplier,
    creditTwapTimeframe,
    debtAuction,
    debtMinimum,
    dexRouter,
    discountsContract,
    liqFee,
    liquidityContract,
    oracleContract,
    oracleTimeLimit,
    osmosisProxy,
    owner,
    rateSlopeMultiplier,
    stabilityPool,
    stakingContract
  }: {
    baseDebtCapMultiplier?: Uint128;
    collateralTwapTimeframe?: number;
    cpcMultiplier?: Decimal;
    creditTwapTimeframe?: number;
    debtAuction?: string;
    debtMinimum?: Uint128;
    dexRouter?: string;
    discountsContract?: string;
    liqFee?: Decimal;
    liquidityContract?: string;
    oracleContract?: string;
    oracleTimeLimit?: number;
    osmosisProxy?: string;
    owner?: string;
    rateSlopeMultiplier?: Decimal;
    stabilityPool?: string;
    stakingContract?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          update_config: {
            base_debt_cap_multiplier: baseDebtCapMultiplier,
            collateral_twap_timeframe: collateralTwapTimeframe,
            cpc_multiplier: cpcMultiplier,
            credit_twap_timeframe: creditTwapTimeframe,
            debt_auction: debtAuction,
            debt_minimum: debtMinimum,
            dex_router: dexRouter,
            discounts_contract: discountsContract,
            liq_fee: liqFee,
            liquidity_contract: liquidityContract,
            oracle_contract: oracleContract,
            oracle_time_limit: oracleTimeLimit,
            osmosis_proxy: osmosisProxy,
            owner,
            rate_slope_multiplier: rateSlopeMultiplier,
            stability_pool: stabilityPool,
            staking_contract: stakingContract
          }
        })),
        funds: _funds
      })
    };
  };
  deposit = ({
    positionId,
    positionOwner
  }: {
    positionId?: Uint128;
    positionOwner?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          deposit: {
            position_id: positionId,
            position_owner: positionOwner
          }
        })),
        funds: _funds
      })
    };
  };
  increaseDebt = ({
    ltv,
    amount,
    mintToAddr,
    positionId
  }: {
    ltv?: Decimal;
    amount?: Uint128;
    mintToAddr?: string;
    positionId: Uint128;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          increase_debt: {
            LTV: ltv,
            amount,
            mint_to_addr: mintToAddr,
            position_id: positionId
          }
        })),
        funds: _funds
      })
    };
  };
  withdraw = ({
    assets,
    positionId,
    sendTo
  }: {
    assets: Asset[];
    positionId: Uint128;
    sendTo?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          withdraw: {
            assets,
            position_id: positionId,
            send_to: sendTo
          }
        })),
        funds: _funds
      })
    };
  };
  repay = ({
    positionId,
    positionOwner,
    sendExcessTo
  }: {
    positionId: Uint128;
    positionOwner?: string;
    sendExcessTo?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          repay: {
            position_id: positionId,
            position_owner: positionOwner,
            send_excess_to: sendExcessTo
          }
        })),
        funds: _funds
      })
    };
  };
  liqRepay = (_funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          liq_repay: {}
        })),
        funds: _funds
      })
    };
  };
  liquidate = ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          liquidate: {
            position_id: positionId,
            position_owner: positionOwner
          }
        })),
        funds: _funds
      })
    };
  };
  redeemCollateral = ({
    maxCollateralPremium
  }: {
    maxCollateralPremium?: number;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          redeem_collateral: {
            max_collateral_premium: maxCollateralPremium
          }
        })),
        funds: _funds
      })
    };
  };
  editRedeemability = ({
    maxLoanRepayment,
    positionIds,
    premium,
    redeemable,
    restrictedCollateralAssets
  }: {
    maxLoanRepayment?: Decimal;
    positionIds: Uint128[];
    premium?: number;
    redeemable?: boolean;
    restrictedCollateralAssets?: string[];
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          edit_redeemability: {
            max_loan_repayment: maxLoanRepayment,
            position_ids: positionIds,
            premium,
            redeemable,
            restricted_collateral_assets: restrictedCollateralAssets
          }
        })),
        funds: _funds
      })
    };
  };
  closePosition = ({
    maxSpread,
    positionId,
    sendTo
  }: {
    maxSpread: Decimal;
    positionId: Uint128;
    sendTo?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          close_position: {
            max_spread: maxSpread,
            position_id: positionId,
            send_to: sendTo
          }
        })),
        funds: _funds
      })
    };
  };
  accrue = ({
    positionIds,
    positionOwner
  }: {
    positionIds: Uint128[];
    positionOwner?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          accrue: {
            position_ids: positionIds,
            position_owner: positionOwner
          }
        })),
        funds: _funds
      })
    };
  };
  mintRevenue = ({
    amount,
    repayFor,
    sendTo
  }: {
    amount?: Uint128;
    repayFor?: UserInfo;
    sendTo?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          mint_revenue: {
            amount,
            repay_for: repayFor,
            send_to: sendTo
          }
        })),
        funds: _funds
      })
    };
  };
  createBasket = ({
    baseInterestRate,
    basketId,
    collateralTypes,
    creditAsset,
    creditPoolInfos,
    creditPrice,
    liqQueue
  }: {
    baseInterestRate?: Decimal;
    basketId: Uint128;
    collateralTypes: CAsset[];
    creditAsset: Asset;
    creditPoolInfos: PoolType[];
    creditPrice: Decimal;
    liqQueue?: string;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          create_basket: {
            base_interest_rate: baseInterestRate,
            basket_id: basketId,
            collateral_types: collateralTypes,
            credit_asset: creditAsset,
            credit_pool_infos: creditPoolInfos,
            credit_price: creditPrice,
            liq_queue: liqQueue
          }
        })),
        funds: _funds
      })
    };
  };
  editBasket = ({
    addedCAsset,
    baseInterestRate,
    collateralSupplyCaps,
    cpcMarginOfError,
    creditAssetTwapPriceSource,
    creditPoolInfos,
    frozen,
    liqQueue,
    multiAssetSupplyCaps,
    negativeRates,
    revToStakers
  }: {
    addedCAsset?: CAsset;
    baseInterestRate?: Decimal;
    collateralSupplyCaps?: SupplyCap[];
    cpcMarginOfError?: Decimal;
    creditAssetTwapPriceSource?: TWAPPoolInfo;
    creditPoolInfos?: PoolType[];
    frozen?: boolean;
    liqQueue?: string;
    multiAssetSupplyCaps?: MultiAssetSupplyCap[];
    negativeRates?: boolean;
    revToStakers?: boolean;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          edit_basket: {
            added_cAsset: addedCAsset,
            base_interest_rate: baseInterestRate,
            collateral_supply_caps: collateralSupplyCaps,
            cpc_margin_of_error: cpcMarginOfError,
            credit_asset_twap_price_source: creditAssetTwapPriceSource,
            credit_pool_infos: creditPoolInfos,
            frozen,
            liq_queue: liqQueue,
            multi_asset_supply_caps: multiAssetSupplyCaps,
            negative_rates: negativeRates,
            rev_to_stakers: revToStakers
          }
        })),
        funds: _funds
      })
    };
  };
  editcAsset = ({
    asset,
    maxLTV,
    maxBorrowLTV
  }: {
    asset: NativeToken;
    maxLTV?: Decimal;
    maxBorrowLTV?: Decimal;
  }, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          editc_asset: {
            asset,
            max_LTV: maxLTV,
            max_borrow_LTV: maxBorrowLTV
          }
        })),
        funds: _funds
      })
    };
  };
  callback = (callbackMsg: CallbackMsg, _funds?: Coin[]): MsgExecuteContractEncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          callback: callbackMsg
        })),
        funds: _funds
      })
    };
  };
}