/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Addr, Decimal, Config, StakeDistribution, Uint128, DelegationResponse, DelegationInfo, Delegation, ExecuteMsg, AssetInfo, FeeEventsResponse, FeeEvent, LiqAsset, InstantiateMsg, QueryMsg, RewardsResponse, Asset, StakeDistributionLog, StakedResponse, StakeDeposit, StakerResponse, TotalStakedResponse } from "./Staking.types";
export interface StakingReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  userStake: ({
    staker
  }: {
    staker: string;
  }) => Promise<StakerResponse>;
  userRewards: ({
    user
  }: {
    user: string;
  }) => Promise<RewardsResponse>;
  staked: ({
    endBefore,
    limit,
    startAfter,
    unstaking
  }: {
    endBefore?: number;
    limit?: number;
    startAfter?: number;
    unstaking: boolean;
  }) => Promise<StakedResponse>;
  delegations: ({
    limit,
    startAfter,
    user
  }: {
    limit?: number;
    startAfter?: string;
    user?: string;
  }) => Promise<DelegationResponse[]>;
  feeEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<FeeEventsResponse>;
  totalStaked: () => Promise<TotalStakedResponse>;
  incentiveSchedule: () => Promise<StakeDistributionLog>;
}
export class StakingQueryClient implements StakingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.userStake = this.userStake.bind(this);
    this.userRewards = this.userRewards.bind(this);
    this.staked = this.staked.bind(this);
    this.delegations = this.delegations.bind(this);
    this.feeEvents = this.feeEvents.bind(this);
    this.totalStaked = this.totalStaked.bind(this);
    this.incentiveSchedule = this.incentiveSchedule.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  userStake = async ({
    staker
  }: {
    staker: string;
  }): Promise<StakerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_stake: {
        staker
      }
    });
  };
  userRewards = async ({
    user
  }: {
    user: string;
  }): Promise<RewardsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_rewards: {
        user
      }
    });
  };
  staked = async ({
    endBefore,
    limit,
    startAfter,
    unstaking
  }: {
    endBefore?: number;
    limit?: number;
    startAfter?: number;
    unstaking: boolean;
  }): Promise<StakedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      staked: {
        end_before: endBefore,
        limit,
        start_after: startAfter,
        unstaking
      }
    });
  };
  delegations = async ({
    limit,
    startAfter,
    user
  }: {
    limit?: number;
    startAfter?: string;
    user?: string;
  }): Promise<DelegationResponse[]> => {
    return this.client.queryContractSmart(this.contractAddress, {
      delegations: {
        limit,
        start_after: startAfter,
        user
      }
    });
  };
  feeEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<FeeEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_events: {
        limit,
        start_after: startAfter
      }
    });
  };
  totalStaked = async (): Promise<TotalStakedResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_staked: {}
    });
  };
  incentiveSchedule = async (): Promise<StakeDistributionLog> => {
    return this.client.queryContractSmart(this.contractAddress, {
      incentive_schedule: {}
    });
  };
}
export interface StakingInterface extends StakingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    auctionContract,
    feeWaitPeriod,
    governanceContract,
    incentiveSchedule,
    keepRawCdt,
    maxCommissionRate,
    mbrnDenom,
    osmosisProxy,
    owner,
    positionsContract,
    unstakingPeriod,
    vestingContract,
    vestingRevMultiplier
  }: {
    auctionContract?: string;
    feeWaitPeriod?: number;
    governanceContract?: string;
    incentiveSchedule?: StakeDistribution;
    keepRawCdt?: boolean;
    maxCommissionRate?: Decimal;
    mbrnDenom?: string;
    osmosisProxy?: string;
    owner?: string;
    positionsContract?: string;
    unstakingPeriod?: number;
    vestingContract?: string;
    vestingRevMultiplier?: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  stake: ({
    user
  }: {
    user?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unstake: ({
    mbrnAmount
  }: {
    mbrnAmount?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  restake: ({
    mbrnAmount
  }: {
    mbrnAmount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimRewards: ({
    restake,
    sendTo
  }: {
    restake: boolean;
    sendTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateDelegations: ({
    commission,
    delegate,
    fluid,
    governatorAddr,
    mbrnAmount,
    votingPowerDelegation
  }: {
    commission?: Decimal;
    delegate?: boolean;
    fluid?: boolean;
    governatorAddr?: string;
    mbrnAmount?: Uint128;
    votingPowerDelegation?: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  delegateFluidDelegations: ({
    governatorAddr,
    mbrnAmount
  }: {
    governatorAddr: string;
    mbrnAmount?: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  depositFee: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  trimFeeEvents: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class StakingClient extends StakingQueryClient implements StakingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.stake = this.stake.bind(this);
    this.unstake = this.unstake.bind(this);
    this.restake = this.restake.bind(this);
    this.claimRewards = this.claimRewards.bind(this);
    this.updateDelegations = this.updateDelegations.bind(this);
    this.delegateFluidDelegations = this.delegateFluidDelegations.bind(this);
    this.depositFee = this.depositFee.bind(this);
    this.trimFeeEvents = this.trimFeeEvents.bind(this);
  }

  updateConfig = async ({
    auctionContract,
    feeWaitPeriod,
    governanceContract,
    incentiveSchedule,
    keepRawCdt,
    maxCommissionRate,
    mbrnDenom,
    osmosisProxy,
    owner,
    positionsContract,
    unstakingPeriod,
    vestingContract,
    vestingRevMultiplier
  }: {
    auctionContract?: string;
    feeWaitPeriod?: number;
    governanceContract?: string;
    incentiveSchedule?: StakeDistribution;
    keepRawCdt?: boolean;
    maxCommissionRate?: Decimal;
    mbrnDenom?: string;
    osmosisProxy?: string;
    owner?: string;
    positionsContract?: string;
    unstakingPeriod?: number;
    vestingContract?: string;
    vestingRevMultiplier?: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        auction_contract: auctionContract,
        fee_wait_period: feeWaitPeriod,
        governance_contract: governanceContract,
        incentive_schedule: incentiveSchedule,
        keep_raw_cdt: keepRawCdt,
        max_commission_rate: maxCommissionRate,
        mbrn_denom: mbrnDenom,
        osmosis_proxy: osmosisProxy,
        owner,
        positions_contract: positionsContract,
        unstaking_period: unstakingPeriod,
        vesting_contract: vestingContract,
        vesting_rev_multiplier: vestingRevMultiplier
      }
    }, fee, memo, _funds);
  };
  stake = async ({
    user
  }: {
    user?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      stake: {
        user
      }
    }, fee, memo, _funds);
  };
  unstake = async ({
    mbrnAmount
  }: {
    mbrnAmount?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unstake: {
        mbrn_amount: mbrnAmount
      }
    }, fee, memo, _funds);
  };
  restake = async ({
    mbrnAmount
  }: {
    mbrnAmount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      restake: {
        mbrn_amount: mbrnAmount
      }
    }, fee, memo, _funds);
  };
  claimRewards = async ({
    restake,
    sendTo
  }: {
    restake: boolean;
    sendTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_rewards: {
        restake,
        send_to: sendTo
      }
    }, fee, memo, _funds);
  };
  updateDelegations = async ({
    commission,
    delegate,
    fluid,
    governatorAddr,
    mbrnAmount,
    votingPowerDelegation
  }: {
    commission?: Decimal;
    delegate?: boolean;
    fluid?: boolean;
    governatorAddr?: string;
    mbrnAmount?: Uint128;
    votingPowerDelegation?: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_delegations: {
        commission,
        delegate,
        fluid,
        governator_addr: governatorAddr,
        mbrn_amount: mbrnAmount,
        voting_power_delegation: votingPowerDelegation
      }
    }, fee, memo, _funds);
  };
  delegateFluidDelegations = async ({
    governatorAddr,
    mbrnAmount
  }: {
    governatorAddr: string;
    mbrnAmount?: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_fluid_delegations: {
        governator_addr: governatorAddr,
        mbrn_amount: mbrnAmount
      }
    }, fee, memo, _funds);
  };
  depositFee = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_fee: {}
    }, fee, memo, _funds);
  };
  trimFeeEvents = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      trim_fee_events: {}
    }, fee, memo, _funds);
  };
}