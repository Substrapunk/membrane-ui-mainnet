/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, BadDebtResponse, PositionUserInfo, NativeToken, Addr, Decimal, BasketPositionsResponse, Position, CAsset, Asset, PoolInfo, LPAssetInfo, Basket, SupplyCap, MultiAssetSupplyCap, CollateralInterestResponse, Config, DebtCap, ExecuteMsg, PoolType, CallbackMsg, UpdateConfig, UserInfo, EditBasket, TWAPPoolInfo, InsolvencyResponse, InsolventPosition, InstantiateMsg, InterestResponse, PositionResponse, QueryMsg, RedeemabilityResponse, PremiumInfo, RedemptionInfo, PositionRedemption } from "./Positions.types";
export interface PositionsReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  getUserPositions: ({
    limit,
    user
  }: {
    limit?: number;
    user: string;
  }) => Promise<PositionResponse[]>;
  getPosition: ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }) => Promise<PositionResponse>;
  getBasketRedeemability: ({
    limit,
    positionOwner,
    startAfter
  }: {
    limit?: number;
    positionOwner?: string;
    startAfter?: number;
  }) => Promise<RedeemabilityResponse>;
  getBasketPositions: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<BasketPositionsResponse>;
  getBasket: () => Promise<Basket>;
  getBasketDebtCaps: () => Promise<DebtCap[]>;
  getBasketBadDebt: () => Promise<BadDebtResponse>;
  getPositionInsolvency: ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }) => Promise<InsolvencyResponse>;
  getCreditRate: () => Promise<InterestResponse>;
  getCollateralInterest: () => Promise<CollateralInterestResponse>;
}
export class PositionsQueryClient implements PositionsReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.getUserPositions = this.getUserPositions.bind(this);
    this.getPosition = this.getPosition.bind(this);
    this.getBasketRedeemability = this.getBasketRedeemability.bind(this);
    this.getBasketPositions = this.getBasketPositions.bind(this);
    this.getBasket = this.getBasket.bind(this);
    this.getBasketDebtCaps = this.getBasketDebtCaps.bind(this);
    this.getBasketBadDebt = this.getBasketBadDebt.bind(this);
    this.getPositionInsolvency = this.getPositionInsolvency.bind(this);
    this.getCreditRate = this.getCreditRate.bind(this);
    this.getCollateralInterest = this.getCollateralInterest.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  getUserPositions = async ({
    limit,
    user
  }: {
    limit?: number;
    user: string;
  }): Promise<PositionResponse[]> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_user_positions: {
        limit,
        user
      }
    });
  };
  getPosition = async ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }): Promise<PositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_position: {
        position_id: positionId,
        position_owner: positionOwner
      }
    });
  };
  getBasketRedeemability = async ({
    limit,
    positionOwner,
    startAfter
  }: {
    limit?: number;
    positionOwner?: string;
    startAfter?: number;
  }): Promise<RedeemabilityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_redeemability: {
        limit,
        position_owner: positionOwner,
        start_after: startAfter
      }
    });
  };
  getBasketPositions = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<BasketPositionsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_positions: {
        limit,
        start_after: startAfter
      }
    });
  };
  getBasket = async (): Promise<Basket> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket: {}
    });
  };
  getBasketDebtCaps = async (): Promise<DebtCap[]> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_debt_caps: {}
    });
  };
  getBasketBadDebt = async (): Promise<BadDebtResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_basket_bad_debt: {}
    });
  };
  getPositionInsolvency = async ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }): Promise<InsolvencyResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_position_insolvency: {
        position_id: positionId,
        position_owner: positionOwner
      }
    });
  };
  getCreditRate = async (): Promise<InterestResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_credit_rate: {}
    });
  };
  getCollateralInterest = async (): Promise<CollateralInterestResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collateral_interest: {}
    });
  };
}
export interface PositionsInterface extends PositionsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    baseDebtCapMultiplier,
    collateralTwapTimeframe,
    cpcMultiplier,
    creditTwapTimeframe,
    debtAuction,
    debtMinimum,
    dexRouter,
    discountsContract,
    liqFee,
    liquidityContract,
    oracleContract,
    oracleTimeLimit,
    osmosisProxy,
    owner,
    rateSlopeMultiplier,
    stabilityPool,
    stakingContract
  }: {
    baseDebtCapMultiplier?: Uint128;
    collateralTwapTimeframe?: number;
    cpcMultiplier?: Decimal;
    creditTwapTimeframe?: number;
    debtAuction?: string;
    debtMinimum?: Uint128;
    dexRouter?: string;
    discountsContract?: string;
    liqFee?: Decimal;
    liquidityContract?: string;
    oracleContract?: string;
    oracleTimeLimit?: number;
    osmosisProxy?: string;
    owner?: string;
    rateSlopeMultiplier?: Decimal;
    stabilityPool?: string;
    stakingContract?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  deposit: ({
    positionId,
    positionOwner
  }: {
    positionId?: Uint128;
    positionOwner?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  increaseDebt: ({
    ltv,
    amount,
    mintToAddr,
    positionId
  }: {
    ltv?: Decimal;
    amount?: Uint128;
    mintToAddr?: string;
    positionId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    assets,
    positionId,
    sendTo
  }: {
    assets: Asset[];
    positionId: Uint128;
    sendTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  repay: ({
    positionId,
    positionOwner,
    sendExcessTo
  }: {
    positionId: Uint128;
    positionOwner?: string;
    sendExcessTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liqRepay: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  liquidate: ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  redeemCollateral: ({
    maxCollateralPremium
  }: {
    maxCollateralPremium?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  editRedeemability: ({
    maxLoanRepayment,
    positionIds,
    premium,
    redeemable,
    restrictedCollateralAssets
  }: {
    maxLoanRepayment?: Decimal;
    positionIds: Uint128[];
    premium?: number;
    redeemable?: boolean;
    restrictedCollateralAssets?: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  closePosition: ({
    maxSpread,
    positionId,
    sendTo
  }: {
    maxSpread: Decimal;
    positionId: Uint128;
    sendTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  accrue: ({
    positionIds,
    positionOwner
  }: {
    positionIds: Uint128[];
    positionOwner?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  mintRevenue: ({
    amount,
    repayFor,
    sendTo
  }: {
    amount?: Uint128;
    repayFor?: UserInfo;
    sendTo?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createBasket: ({
    baseInterestRate,
    basketId,
    collateralTypes,
    creditAsset,
    creditPoolInfos,
    creditPrice,
    liqQueue
  }: {
    baseInterestRate?: Decimal;
    basketId: Uint128;
    collateralTypes: CAsset[];
    creditAsset: Asset;
    creditPoolInfos: PoolType[];
    creditPrice: Decimal;
    liqQueue?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  editBasket: ({
    addedCAsset,
    baseInterestRate,
    collateralSupplyCaps,
    cpcMarginOfError,
    creditAssetTwapPriceSource,
    creditPoolInfos,
    frozen,
    liqQueue,
    multiAssetSupplyCaps,
    negativeRates,
    revToStakers
  }: {
    addedCAsset?: CAsset;
    baseInterestRate?: Decimal;
    collateralSupplyCaps?: SupplyCap[];
    cpcMarginOfError?: Decimal;
    creditAssetTwapPriceSource?: TWAPPoolInfo;
    creditPoolInfos?: PoolType[];
    frozen?: boolean;
    liqQueue?: string;
    multiAssetSupplyCaps?: MultiAssetSupplyCap[];
    negativeRates?: boolean;
    revToStakers?: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  editcAsset: ({
    asset,
    maxLTV,
    maxBorrowLTV
  }: {
    asset: NativeToken;
    maxLTV?: Decimal;
    maxBorrowLTV?: Decimal;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  callback: (callbackMsg: CallbackMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class PositionsClient extends PositionsQueryClient implements PositionsInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.deposit = this.deposit.bind(this);
    this.increaseDebt = this.increaseDebt.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.repay = this.repay.bind(this);
    this.liqRepay = this.liqRepay.bind(this);
    this.liquidate = this.liquidate.bind(this);
    this.redeemCollateral = this.redeemCollateral.bind(this);
    this.editRedeemability = this.editRedeemability.bind(this);
    this.closePosition = this.closePosition.bind(this);
    this.accrue = this.accrue.bind(this);
    this.mintRevenue = this.mintRevenue.bind(this);
    this.createBasket = this.createBasket.bind(this);
    this.editBasket = this.editBasket.bind(this);
    this.editcAsset = this.editcAsset.bind(this);
    this.callback = this.callback.bind(this);
  }

  updateConfig = async ({
    baseDebtCapMultiplier,
    collateralTwapTimeframe,
    cpcMultiplier,
    creditTwapTimeframe,
    debtAuction,
    debtMinimum,
    dexRouter,
    discountsContract,
    liqFee,
    liquidityContract,
    oracleContract,
    oracleTimeLimit,
    osmosisProxy,
    owner,
    rateSlopeMultiplier,
    stabilityPool,
    stakingContract
  }: {
    baseDebtCapMultiplier?: Uint128;
    collateralTwapTimeframe?: number;
    cpcMultiplier?: Decimal;
    creditTwapTimeframe?: number;
    debtAuction?: string;
    debtMinimum?: Uint128;
    dexRouter?: string;
    discountsContract?: string;
    liqFee?: Decimal;
    liquidityContract?: string;
    oracleContract?: string;
    oracleTimeLimit?: number;
    osmosisProxy?: string;
    owner?: string;
    rateSlopeMultiplier?: Decimal;
    stabilityPool?: string;
    stakingContract?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        base_debt_cap_multiplier: baseDebtCapMultiplier,
        collateral_twap_timeframe: collateralTwapTimeframe,
        cpc_multiplier: cpcMultiplier,
        credit_twap_timeframe: creditTwapTimeframe,
        debt_auction: debtAuction,
        debt_minimum: debtMinimum,
        dex_router: dexRouter,
        discounts_contract: discountsContract,
        liq_fee: liqFee,
        liquidity_contract: liquidityContract,
        oracle_contract: oracleContract,
        oracle_time_limit: oracleTimeLimit,
        osmosis_proxy: osmosisProxy,
        owner,
        rate_slope_multiplier: rateSlopeMultiplier,
        stability_pool: stabilityPool,
        staking_contract: stakingContract
      }
    }, fee, memo, _funds);
  };
  deposit = async ({
    positionId,
    positionOwner
  }: {
    positionId?: Uint128;
    positionOwner?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit: {
        position_id: positionId,
        position_owner: positionOwner
      }
    }, fee, memo, funds);
  };
  increaseDebt = async ({
    ltv,
    amount,
    mintToAddr,
    positionId
  }: {
    ltv?: Decimal;
    amount?: Uint128;
    mintToAddr?: string;
    positionId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      increase_debt: {
        LTV: ltv,
        amount,
        mint_to_addr: mintToAddr,
        position_id: positionId
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    assets,
    positionId,
    sendTo
  }: {
    assets: Asset[];
    positionId: Uint128;
    sendTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        assets,
        position_id: positionId,
        send_to: sendTo
      }
    }, fee, memo, _funds);
  };
  repay = async ({
    positionId,
    positionOwner,
    sendExcessTo
  }: {
    positionId: Uint128;
    positionOwner?: string;
    sendExcessTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      repay: {
        position_id: positionId,
        position_owner: positionOwner,
        send_excess_to: sendExcessTo
      }
    }, fee, memo, _funds);
  };
  liqRepay = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liq_repay: {}
    }, fee, memo, _funds);
  };
  liquidate = async ({
    positionId,
    positionOwner
  }: {
    positionId: Uint128;
    positionOwner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      liquidate: {
        position_id: positionId,
        position_owner: positionOwner
      }
    }, fee, memo, _funds);
  };
  redeemCollateral = async ({
    maxCollateralPremium
  }: {
    maxCollateralPremium?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      redeem_collateral: {
        max_collateral_premium: maxCollateralPremium
      }
    }, fee, memo, _funds);
  };
  editRedeemability = async ({
    maxLoanRepayment,
    positionIds,
    premium,
    redeemable,
    restrictedCollateralAssets
  }: {
    maxLoanRepayment?: Decimal;
    positionIds: Uint128[];
    premium?: number;
    redeemable?: boolean;
    restrictedCollateralAssets?: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_redeemability: {
        max_loan_repayment: maxLoanRepayment,
        position_ids: positionIds,
        premium,
        redeemable,
        restricted_collateral_assets: restrictedCollateralAssets
      }
    }, fee, memo, _funds);
  };
  closePosition = async ({
    maxSpread,
    positionId,
    sendTo
  }: {
    maxSpread: Decimal;
    positionId: Uint128;
    sendTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      close_position: {
        max_spread: maxSpread,
        position_id: positionId,
        send_to: sendTo
      }
    }, fee, memo, _funds);
  };
  accrue = async ({
    positionIds,
    positionOwner
  }: {
    positionIds: Uint128[];
    positionOwner?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accrue: {
        position_ids: positionIds,
        position_owner: positionOwner
      }
    }, fee, memo, _funds);
  };
  mintRevenue = async ({
    amount,
    repayFor,
    sendTo
  }: {
    amount?: Uint128;
    repayFor?: UserInfo;
    sendTo?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint_revenue: {
        amount,
        repay_for: repayFor,
        send_to: sendTo
      }
    }, fee, memo, _funds);
  };
  createBasket = async ({
    baseInterestRate,
    basketId,
    collateralTypes,
    creditAsset,
    creditPoolInfos,
    creditPrice,
    liqQueue
  }: {
    baseInterestRate?: Decimal;
    basketId: Uint128;
    collateralTypes: CAsset[];
    creditAsset: Asset;
    creditPoolInfos: PoolType[];
    creditPrice: Decimal;
    liqQueue?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_basket: {
        base_interest_rate: baseInterestRate,
        basket_id: basketId,
        collateral_types: collateralTypes,
        credit_asset: creditAsset,
        credit_pool_infos: creditPoolInfos,
        credit_price: creditPrice,
        liq_queue: liqQueue
      }
    }, fee, memo, _funds);
  };
  editBasket = async ({
    addedCAsset,
    baseInterestRate,
    collateralSupplyCaps,
    cpcMarginOfError,
    creditAssetTwapPriceSource,
    creditPoolInfos,
    frozen,
    liqQueue,
    multiAssetSupplyCaps,
    negativeRates,
    revToStakers
  }: {
    addedCAsset?: CAsset;
    baseInterestRate?: Decimal;
    collateralSupplyCaps?: SupplyCap[];
    cpcMarginOfError?: Decimal;
    creditAssetTwapPriceSource?: TWAPPoolInfo;
    creditPoolInfos?: PoolType[];
    frozen?: boolean;
    liqQueue?: string;
    multiAssetSupplyCaps?: MultiAssetSupplyCap[];
    negativeRates?: boolean;
    revToStakers?: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      edit_basket: {
        added_cAsset: addedCAsset,
        base_interest_rate: baseInterestRate,
        collateral_supply_caps: collateralSupplyCaps,
        cpc_margin_of_error: cpcMarginOfError,
        credit_asset_twap_price_source: creditAssetTwapPriceSource,
        credit_pool_infos: creditPoolInfos,
        frozen,
        liq_queue: liqQueue,
        multi_asset_supply_caps: multiAssetSupplyCaps,
        negative_rates: negativeRates,
        rev_to_stakers: revToStakers
      }
    }, fee, memo, _funds);
  };
  editcAsset = async ({
    asset,
    maxLTV,
    maxBorrowLTV
  }: {
    asset: NativeToken;
    maxLTV?: Decimal;
    maxBorrowLTV?: Decimal;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      editc_asset: {
        asset,
        max_LTV: maxLTV,
        max_borrow_LTV: maxBorrowLTV
      }
    }, fee, memo, _funds);
  };
  callback = async (callbackMsg: CallbackMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      callback: callbackMsg
    }, fee, memo, _funds);
  };
}